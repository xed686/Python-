# 给你一个整数数组 nums，其中可能包含重复数字，返回该数组所有不重复的全排列。
# 示例 1
# 输入：nums = [1,1,2]
# 输出：
# [[1,1,2], [1,2,1], [2,1,1]]
# 示例 2
# 输入：nums = [1,2,3]
# 输出：
# [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
# 示例 3
# 输入：nums = [1]
# 输出：[[1]]
# 要求
# •  答案中不能有重复排列
# •  nums 长度 ≤ 8，数值 -10 ~ 10
# •  必须处理重复数字（去重）
# 核心思路提示
# •  和子集 II 类似：排序 + 同一层去重
# •  但和子集不同的是：全排列要用所有元素（没有“选或不选”）
# •  用一个 used 数组记录每个位置是否用过（因为顺序重要，不能用索引递增）
# •  或者用排序 + 去重 + used 数组
def jieshou(c_nums):
    c_nums.sort()
    path = []#用于接收合法子集
    used = [False] * len(c_nums)#False为还未选择 True为已选择
    def backtrack(c_path):
        if len(c_path)==len(c_nums):#当c_path的列表长度与c_nums相等时将c_path加上
            path.append(c_path[:])
            return
        for i in range(len(c_nums)):
            if used[i] == True:
                continue
            #去重核心條件：
            #    如果目前這個數字跟前一個數字相同（c_nums[i] == c_nums[i-1]）
            #    且 前一個數字還沒被用過（not used[i-1]）
            #    那麼我們就跳過目前這個 i
            #    比喻：相同的數字，我們只允許「從左邊第一個沒用過的」開始選
            #          後面的相同數字要等前面的被用掉之後才有資格被選
            # 个人理解：该去重是对同一层来说 如果有两个及以上的相同的数来说 当第一个数被选上
            #         为了不让第二乃至后面已经相同的数被选上 采用改去重方法能很好的避免
            #         而在下面的层中 这些重复的数才会被依次排列
            # 如[11223444] 第0层中挑选出来1 2 3 4 而第1层中挑选出来第0层中的第0个循环11 12 13 14
            #                                                 第0层中的第1个循环21 22 23 24
            #                                                 第0层中的第2个循环31 32 34
            #                                                 第0层中的第3个循环41 42 43 44往后的步骤依次类推
            # Al描述：在回溯的每一层 只允许使用"当前这一层中，第一次出现的那个值"作为选择起点
            #       后面相同的值，只有在“前面那个相同的值已经被上一层或更早的层选走(用掉了)”
            #       的情况下，才被允许在本层选中
            # Al总结： “同一层只让‘该值在本层第一次出现的位置’有机会被选；
            # 相同的值要想在同一层被多次使用是不可能的，但在不同层（不同前缀下）
            # 是可以多次使用的，只要它前面的‘同值兄弟’已经被更早的层消耗掉了。”
            if i>0 and c_nums[i]==c_nums[i-1] and not used[i-1]:
                continue
            c_path.append(c_nums[i])
            used[i] = True
            backtrack(c_path)
            used[i] = False
            c_path.pop()
    backtrack([])
    return path

def zhuanhuan(n_nums):
    nums = [int(i) for i in n_nums.strip()]#将n_nums转换为列表 str.strip() 用于移除字符串首尾的空白字符（包括空格、换行符 \n、制表符 \t 等）
    #strip(字符) 可指定移除首尾的特定字符（比如 strip("!") 移除首尾的感叹号）
    return jieshou(nums)

n = input("请你输入一串数字： ")
if len(n) > 8:
    print("输入错误 请你重新输入")
else:
    print("你获得的组合如下：")
    for i in zhuanhuan(n):
        print(i)